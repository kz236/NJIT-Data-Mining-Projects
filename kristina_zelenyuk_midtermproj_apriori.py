# -*- coding: utf-8 -*-
"""Kristina_Zelenyuk_Midtermproj_Apriori.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YSdNCfDhMuO4qqRRJS3IeiLC9eJR1mRL

import packages and files
"""

import time
import pandas as pd
import itertools as itr
from ftfy import fix_text

# read data file
file = input('Please enter filepath to list of individual items.')
start=time.time()
items = pd.read_csv(file, encoding='cp1252')
#initialize support and confidence thresholds
minsup=float(input('Please enter minimum support threshold.'))
minconf=int(input('please enter minimum confidence threshold.'))
# generate all 1 - itemsets
def oneItemsets(items):
  oneItemList = []
  for i in items['Item Name']:
    oneItemList.append(fix_text(i))
  return oneItemList

one=oneItemsets(items) #list of all items

"""import and count transactions"""

file2 = input('please enter filepath to list of transactions')
transactions = pd.read_csv(file2, encoding='cp1252')

translist=[]
for transaction in transactions['trans']:
  translist.append((fix_text(str(transaction))))

def countTrans(transactions):
  count=0
  for transaction in transactions:
    count+=1
  return count

size= countTrans(translist)

"""initialize dictionaries and create first group of single item sets"""

Isets = {} #dict of all possible itemsets
Freq={} #dict of all frequent itemsets
Support={} #dict of all supports for freq
itemsetSize=1
Discarded={itemsetSize:[]} #dict of all infrequent itemsets
Isets.update({itemsetSize : [[i] for i in one]})

"""function to calculate support of itemsets


"""

def itemSetSupport(transactions, itemSet):
    freq=[]
    count=0
    for transaction in transactions:
        matching = True
        for item in itemSet:
            if str(item) not in str(transaction):
                matching = False
                break
        if matching:
              count +=1  #count itemset ocurrences
    support=count/size #calculate support
    return support

"""function to get frequent itemsets"""

def getFrequent(itemsets, transactions, minsup, previouslyDiscarded ):
  freq=[]
  supp=[]
  newDiscarded=[]

  k=len(previouslyDiscarded.keys())
  for s in range(0,len(itemsets)):
    alreadyDiscarded= False
    if k>0:
      for i in previouslyDiscarded[k]: #check whether a subset was considered unfrequent
        if set(i).issubset(set(itemsets[s])):
          alreadyDiscarded= True
          break
    if not alreadyDiscarded:
      support = itemSetSupport(transactions, itemsets[s])
      if support >= minsup: #determine if frequent
        freq.append(itemsets[s])
        supp.append(support)
      else:
        newDiscarded.append(itemsets[s])
  return freq, supp, newDiscarded

frequent, support, newDiscarded = getFrequent(Isets[itemsetSize], translist, minsup, Discarded)
Discarded.update({itemsetSize:newDiscarded})
Freq.update({itemsetSize:frequent})
Support.update({itemsetSize:support})

"""Create K+1 itemsets"""

def nItems(items, n):
   combination = []
   combination.extend(itr.combinations(items, n))
   return combination

"""Iterate through k-size itemsets"""

k = itemsetSize+1
c=False #determine whether last k-itemsets had any frequent
while not c:
  Isets.update({k : nItems(one, k)})
  freq, supp, newDiscarded = getFrequent(Isets[k], translist, minsup, Discarded)
  Discarded.update({k:newDiscarded})
  Freq.update({k:freq})
  Support.update({k:supp})
  if len(Freq[k]) == 0:
    c=True
  k+=1

"""function to create powerset of all possible rule combinations"""

def powerset(s):
  return list(itr.chain.from_iterable(itr.combinations(s,r) for r in range(1, len(s)+1)))

"""Generate Association Rules"""

for i in range(1, len(Freq)+1):
  for j in range(0, len(Freq[i])):
    s=powerset(Freq[i][j]) #create set of all possible combinations of rules
    s.pop()
    for a in s:
      S=set(a)
      X=set(Freq[i][j])
      XS=set(X-S)
      xSupp=itemSetSupport(translist, X)
      xsSupp=itemSetSupport(translist, XS)
      sSupp=itemSetSupport(translist, S)
      conf=(xSupp/sSupp)*100
      if conf>=minconf and xSupp>=minsup:
        print()
        print(str(S)+'->'+str(XS)+' Support:'+str(xSupp)+' Confidence:'+str(conf))

end=time.time()
runtime=end-start

print('Apriori Runtime')
print(runtime)